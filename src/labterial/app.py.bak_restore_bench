import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np # Necesario para trapz (integrales)
import os
import sys

current_dir = os.path.dirname(os.path.abspath(__file__))
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)

try:
    from .database_mgr import get_all_materials, insert_from_dataframe
    from .physics import simular_ensayo
except ImportError:
    from database_mgr import get_all_materials, insert_from_dataframe
    from physics import simular_ensayo

MPA_TO_KSI = 0.1450377

LABEL_MAP = {
    "name": "Material", "category": "Categor√≠a",
    "elastic_modulus": "M√≥dulo de Young (E)", "yield_strength": "L√≠mite El√°stico (Sy)",
    "ultimate_strength": "Resistencia M√°xima (Su)", "poisson_ratio": "Coeficiente Poisson (ŒΩ)",
    "density": "Densidad", "cost": "Costo", "max_temp": "Temp. M√°x"
}

def translate_df(df):
    return df.rename(columns=LABEL_MAP)

def configure_page():
    st.set_page_config(page_title="Labterial Edu", layout="wide", page_icon="üéì")
    st.title("üéì Labterial: Laboratorio Educativo")

def load_data():
    return get_all_materials()

def render_sidebar(df_raw):
    st.sidebar.header("üîç Filtros")
    st.sidebar.divider()
    
    st.sidebar.subheader("üë®‚Äçüè´ Panel Docente")
    show_math = st.sidebar.checkbox("Explicaci√≥n Matem√°tica", value=False)
    show_energy = st.sidebar.checkbox("An√°lisis de Energ√≠a (√Åreas)", value=False)
    
    st.sidebar.divider()
    if isinstance(df_raw, pd.DataFrame) and 'category' in df_raw.columns:
        cats = df_raw['category'].unique().tolist()
        sel_cats = st.sidebar.multiselect("Categor√≠a", cats, default=cats)
        if sel_cats: return df_raw[df_raw['category'].isin(sel_cats)], show_math, show_energy
    return df_raw, show_math, show_energy

def render_tab_management(df_mats):
    c1, c2 = st.columns([2, 1])
    with c1:
        st.subheader("üìã Inventario")
        st.dataframe(translate_df(df_mats), use_container_width=True, height=400)
    with c2:
        st.subheader("Gesti√≥n")
        with st.expander("üì• Importar CSV"):
            up = st.file_uploader("Archivo", type=['csv'])
            if up and st.button("Cargar"):
                try:
                    df_new = pd.read_csv(up)
                    a, i, e = insert_from_dataframe(df_new)
                    if e: st.error(e)
                    else: st.success(f"Ok: {a}"); st.rerun()
                except Exception as ex: st.error(ex)
        try:
            from pathlib import Path
            pkg = __package__ if __package__ else 'labterial'
            db_path = Path.home() / f".{pkg}" / "materials.db"
            if not db_path.exists(): db_path = Path(__file__).parent.parent.parent / 'data' / 'materials.db'
            if db_path.exists():
                with open(db_path, "rb") as fp: st.download_button("üíæ Backup BD", fp, "materials.db")
        except: pass

# --- NUEVO: VISUALIZADOR DE PROBETA ---
def render_specimen_visualizer(current_strain, poisson, modo):
    """Dibuja una probeta esquem√°tica que se deforma."""
    
    # Dimensiones iniciales arbitrarias
    L0 = 10.0
    W0 = 2.0
    
    # Calcular deformaci√≥n
    delta_L = L0 * current_strain
    
    # Efecto Poisson (Adelgazamiento)
    # Si estiro (strain > 0), el ancho baja. Si aplasto, el ancho sube.
    # En compresion strain entra positivo como magnitud, ajustamos signo logico
    signo = -1 if modo == "Compresion" else 1
    lateral_strain = -poisson * (current_strain * signo)
    
    # Limite visual para que no desaparezca la barra
    lateral_strain = max(-0.9, min(2.0, lateral_strain))
    
    W_final = W0 * (1 + lateral_strain)
    L_final = L0 + (delta_L * signo)
    
    if modo == "Torsion":
        # Para torsi√≥n mostramos un c√≠rculo que gira una linea
        fig = go.Figure()
        # Circulo base
        fig.add_shape(type="circle", x0=-1, y0=-1, x1=1, y1=1, line_color="black")
        # Linea indicadora de angulo
        angle = current_strain # radianes
        x_end = np.cos(angle)
        y_end = np.sin(angle)
        fig.add_trace(go.Scatter(x=[0, x_end], y=[0, y_end], mode='lines+markers', line=dict(color='red', width=4)))
        fig.update_layout(title="Vista Transversal (Giro)", xaxis=dict(range=[-1.5, 1.5], visible=False), yaxis=dict(range=[-1.5, 1.5], visible=False), height=150, margin=dict(l=0, r=0, t=30, b=0))
        return fig

    # Para Traccion/Compresion: Rectangulo
    fig = go.Figure()
    
    # Probeta Original (Fantasma)
    fig.add_shape(type="rect", x0=0, y0=-W0/2, x1=L0, y1=W0/2, line=dict(color="gray", dash="dot"))
    
    # Probeta Deformada
    color = "royalblue" if modo=="Tension" else "firebrick"
    fig.add_shape(type="rect", x0=0, y0=-W_final/2, x1=L_final, y1=W_final/2, fillcolor=color, line=dict(color="black"), opacity=0.6)
    
    fig.update_layout(
        title="Visualizaci√≥n de Probeta (Exagerada)",
        xaxis=dict(range=[-1, L0*1.5], visible=False),
        yaxis=dict(range=[-W0*2, W0*2], visible=False),
        height=150,
        margin=dict(l=0, r=0, t=30, b=0),
        showlegend=False
    )
    return fig

def render_math_explainer(dat, modo, units, factor, unit_label, df_sim, show_energy):
    st.info("üí° **An√°lisis Pedag√≥gico**")
    
    E = dat['elastic_modulus'] * factor
    Sy = dat['yield_strength'] * factor
    
    t1, t2, t3 = st.tabs(["üìê Ecuaciones", "‚ö° Energ√≠a (√Åreas)", "üß† Conceptos"])
    
    with t1:
        c1, c2 = st.columns(2)
        with c1:
            st.markdown("**Zona El√°stica (Lineal)**")
            st.latex(r"\sigma = E \cdot \epsilon")
            st.caption(f"Pendiente E = {E:.0f} {unit_label}")
        with c2:
            st.markdown("**Zona Pl√°stica**")
            st.latex(r"\sigma = S_y + K \cdot \epsilon^n")
            st.caption(f"Inicia en Sy = {Sy:.0f} {unit_label}")
            
    with t2:
        if show_energy and not df_sim.empty:
            # Calcular Energ√≠a (√Årea bajo la curva)
            # Energ√≠a = Integral(sigma * d_epsilon)
            # Unidades: MPa * (mm/mm) = MJ/m3 (Energ√≠a Espec√≠fica)
            
            # 1. Resiliencia (Hasta Sy)
            # Filtramos datos hasta el punto de fluencia
            limit_elastic = Sy / E
            df_elastic = df_sim[df_sim['Deformacion (rad)' if 'rad' in df_sim.columns else 'Deformacion (mm/mm)'] <= limit_elastic]
            
            if not df_elastic.empty:
                # Area triangulo aprox
                resilience = 0.5 * (df_elastic.iloc[-1]['Esfuerzo (MPa)'] * factor) * df_elastic.iloc[-1].get('Deformacion (rad)', df_elastic.iloc[-1].get('Deformacion (mm/mm)'))
                st.metric("Resiliencia (Energ√≠a El√°stica)", f"{resilience:.2f} MJ/m¬≥", help="Energ√≠a que el material devuelve si se suelta la carga.")
            
            # 2. Tenacidad (Total)
            # Integral num√©rica trapecial de toda la curva
            x = df_sim['Deformacion (rad)' if 'rad' in df_sim.columns else 'Deformacion (mm/mm)'].fillna(0)
            y = df_sim['Esfuerzo (MPa)'].fillna(0) * factor
            toughness = np.trapz(y, x)
            
            st.metric("Tenacidad (Energ√≠a Total Absorbida)", f"{toughness:.2f} MJ/m¬≥", help="Energ√≠a total absorbida hasta la ruptura. Clave para impactos.")
        else:
            st.write("Activa 'An√°lisis de Energ√≠a' en el panel lateral para ver c√°lculos.")

    with t3:
        st.markdown("""
        * **M√≥dulo de Young (E):** Rigidez. ¬øQu√© tanto se opone a ser estirado?
        * **L√≠mite El√°stico ($S_y$):** El punto de no retorno. Pasado esto, la deformaci√≥n es permanente.
        * **Ductilidad:** ¬øQu√© tanto se estira antes de romper? (Ancho de la gr√°fica).
        """)

def render_tab_simulation(df_mats, show_math, show_energy):
    if df_mats.empty: st.warning("Sin datos."); return
    st.header("üî¨ Laboratorio Virtual")
    
    col_ctrl, col_plot = st.columns([1, 3])

    with col_ctrl:
        st.subheader("Configuraci√≥n")
        units = st.radio("Unidades", ["SI (MPa)", "Imperial (ksi)"], horizontal=True)
        is_imperial = "Imperial" in units
        unit_label = "ksi" if is_imperial else "MPa"
        factor = MPA_TO_KSI if is_imperial else 1.0
        
        st.divider()
        mats_avail = df_mats['name'].unique()
        sel = st.multiselect("Probetas", options=mats_avail, default=[mats_avail[0]] if len(mats_avail)>0 else None)
        
        st.divider()
        modo = st.radio("Ensayo", ["Tension", "Compresion", "Torsion"])
        lbl = "L√≠mite (%)" if modo!="Torsion" else "√Ångulo (rad)"
        max_v = 40.0 if modo!="Torsion" else 1.0
        slider = st.slider(lbl, 0.1, max_v, 15.0)
        limit = slider/100 if modo!="Torsion" else slider
        
        # --- VISUALIZADOR PROBETA ---
        if len(sel) == 1:
            st.divider()
            # Obtener Poisson del material
            dat_vis = df_mats[df_mats['name'] == sel[0]].iloc[0]
            nu_vis = dat_vis.get('poisson_ratio', 0.3)
            # Renderizar probeta usando el valor actual del slider como "deformacion actual"
            # (Pedag√≥gicamente mostramos c√≥mo se ver√≠a al final del ensayo)
            fig_vis = render_specimen_visualizer(limit, nu_vis, modo)
            st.plotly_chart(fig_vis, use_container_width=True, config={'displayModeBar': False})
            st.caption("Estado de la probeta al final del recorrido.")

    with col_plot:
        if not sel: st.info("Selecciona material."); return
        
        fig = go.Figure()
        
        # Variable para guardar DF del primer material para el explainer
        df_sim_single = pd.DataFrame()

        for mat in sel:
            dat = df_mats[df_mats['name'] == mat].iloc[0]
            props = dict(dat); props['category'] = dat.get('category', 'Metal')
            
            df_sim = simular_ensayo(props, modo, max_strain_machine=limit)
            if mat == sel[0]: df_sim_single = df_sim.copy() # Guardar para uso pedag√≥gico
            
            y_vals = df_sim["Esfuerzo (MPa)"] * factor
            x_col = "Deformacion (%)" if modo!="Torsion" else "Deformacion (rad)"
            
            # Si activamos energ√≠a, sombreamos el √°rea
            fill_mode = 'tozeroy' if (show_energy and len(sel)==1) else 'none'
            
            fig.add_trace(go.Scatter(
                x=df_sim[x_col], y=y_vals, mode='lines', name=mat, 
                line=dict(width=3), fill=fill_mode
            ))

        t_map = {"Tension": "Tracci√≥n", "Compresion": "Compresi√≥n", "Torsion": "Torsi√≥n"}
        fig.update_layout(title=f"Curvas ({units}) - {t_map[modo]}", 
                          xaxis_title=x_col.replace("Deformacion", "Deformaci√≥n"), 
                          yaxis_title=f"Esfuerzo ({unit_label})", 
                          hovermode="x unified", template="plotly_white")
        fig.update_xaxes(range=[0, slider])
        st.plotly_chart(fig, use_container_width=True)
        
        # EXPLICACI√ìN PEDAG√ìGICA
        if show_math and len(sel) == 1:
            render_math_explainer(
                df_mats[df_mats['name'] == sel[0]].iloc[0], 
                modo, units, factor, unit_label, df_sim_single, show_energy
            )

def render_tab_reports(df_mats):
    st.header("üìë Reportes")
    if df_mats.empty: return
    c1, c2 = st.columns(2)
    with c1: sel = st.multiselect("Materiales", df_mats['name'].unique())
    with c2: cols = st.multiselect("Propiedades", [c for c in df_mats.columns if c!='id'], default=['name','yield_strength'], format_func=lambda x: LABEL_MAP.get(x, x))
    if sel and cols:
        df = df_mats[df_mats['name'].isin(sel)][cols]
        st.dataframe(df, use_container_width=True)
        t1, t2 = st.tabs(["CSV", "LaTeX"])
        with t1: st.download_button("Descargar CSV", df.to_csv(index=False).encode('utf-8'), "data.csv", "text/csv")
        with t2: st.code(df.to_latex(index=False, float_format="%.2f"), language='latex')

def main():
    configure_page()
    try: df_raw = load_data()
    except: return
    df_mats, show_math, show_energy = render_sidebar(df_raw)
    
    tab1, tab2, tab3 = st.tabs(["üì¶ Base de Datos", "üìà Simulaci√≥n", "üìë Reportes"])
    with tab1: render_tab_management(df_mats)
    with tab2: render_tab_simulation(df_mats, show_math, show_energy)
    with tab3: render_tab_reports(df_mats)

if __name__ == "__main__":
    main()
